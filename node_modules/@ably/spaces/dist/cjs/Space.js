"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ably_1 = __importDefault(require("ably"));
const EventEmitter_js_1 = __importStar(require("./utilities/EventEmitter.js"));
const Locations_js_1 = __importDefault(require("./Locations.js"));
const Cursors_js_1 = __importDefault(require("./Cursors.js"));
const Members_js_1 = __importDefault(require("./Members.js"));
const Locks_js_1 = __importDefault(require("./Locks.js"));
const SpaceUpdate_js_1 = __importDefault(require("./SpaceUpdate.js"));
const Errors_js_1 = require("./Errors.js");
const is_js_1 = require("./utilities/is.js");
const version_js_1 = require("./version.js");
const SPACE_CHANNEL_TAG = '::$space';
const SPACE_OPTIONS_DEFAULTS = {
    offlineTimeout: 120000,
    cursors: {
        outboundBatchInterval: 25,
        paginationLimit: 5,
    },
};
/**
 * <!-- BEGIN WEBSITE DOCUMENTATION (https://github.com/ably/docs/blob/cb5de6a6a40abdcb0d9d5af825928dd62dc1ca64/content/spaces/space.textile?plain=1#L9-L22) -->
 * A space is a virtual area of your application in which realtime collaboration between users can take place. You can have any number of virtual spaces within an application, with a single space being anything from a web page, a sheet within a spreadsheet, an individual slide in a slideshow, or the entire slideshow itself.
 *
 * The following features can be implemented within a space:
 *
 * - Avatar stack, via the {@link members | `members`} property
 * - Member location, via the {@link locations | `locations`} property
 * - Live cursors, via the {@link cursors | `cursors`} property
 * - Component locking, via the {@link locks | `locks`} property
 *
 * A `Space` instance consists of a state object that represents the realtime status of all members in a given virtual space. This includes a list of which members are currently online or have recently left and each member’s location within the application. The position of members’ cursors are excluded from the space state due to their high frequency of updates. In the beta release, which UI components members have locked are also excluded from the space state.
 *
 * Space state can be {@link subscribe | subscribed} to by using a `Space` object. Alternatively, subscription listeners can be registered for individual features, such as avatar stack events and member location updates. These individual subscription listeners are intended to provide flexibility when implementing collaborative features. Individual listeners are client-side filtered events, so irrespective of whether you choose to subscribe to the space state or individual listeners, each event only counts as a single message.
 *
 * To subscribe to any events in a space, you first need to create or retrieve a space.
 *
 * <!-- END WEBSITE DOCUMENTATION -->
 *
 * <!-- BEGIN CLASS-DEFINITIONS DOCUMENTATION -->
 * An instance of a Space created using {@link default.get | spaces.get}. Inherits from {@link EventEmitter}.
 * <!-- END CLASS-DEFINITIONS DOCUMENTATION -->
 */
class Space extends EventEmitter_js_1.default {
    /** @internal */
    constructor(name, client, options) {
        super();
        this.presenceUpdate = ({ data, extras }) => {
            if (!extras) {
                return this.channel.presence.update(data);
            }
            return this.channel.presence.update(ably_1.default.Realtime.PresenceMessage.fromValues({ data, extras }));
        };
        this.presenceEnter = ({ data, extras }) => {
            if (!extras) {
                return this.channel.presence.enter(data);
            }
            return this.channel.presence.enter(ably_1.default.Realtime.PresenceMessage.fromValues({ data, extras }));
        };
        this.presenceLeave = ({ data, extras }) => {
            if (!extras) {
                return this.channel.presence.leave(data);
            }
            return this.channel.presence.leave(ably_1.default.Realtime.PresenceMessage.fromValues({ data, extras }));
        };
        this.client = client;
        this.options = this.setOptions(options);
        this.connectionId = this.client.connection.id;
        this.name = name;
        this.channelName = `${name}${SPACE_CHANNEL_TAG}`;
        this.channel = this.client.channels.get(this.channelName, { params: { agent: `spaces/${version_js_1.VERSION}` } });
        this.onPresenceUpdate = this.onPresenceUpdate.bind(this);
        this.channel.presence.subscribe(this.onPresenceUpdate);
        this.locations = new Locations_js_1.default(this, this.presenceUpdate);
        this.cursors = new Cursors_js_1.default(this);
        this.members = new Members_js_1.default(this);
        this.locks = new Locks_js_1.default(this, this.presenceUpdate);
    }
    setOptions(options) {
        var _a, _b, _c, _d, _e;
        const { offlineTimeout, cursors: { outboundBatchInterval, paginationLimit }, } = SPACE_OPTIONS_DEFAULTS;
        return {
            offlineTimeout: (_a = options === null || options === void 0 ? void 0 : options.offlineTimeout) !== null && _a !== void 0 ? _a : offlineTimeout,
            cursors: {
                outboundBatchInterval: (_c = (_b = options === null || options === void 0 ? void 0 : options.cursors) === null || _b === void 0 ? void 0 : _b.outboundBatchInterval) !== null && _c !== void 0 ? _c : outboundBatchInterval,
                paginationLimit: (_e = (_d = options === null || options === void 0 ? void 0 : options.cursors) === null || _d === void 0 ? void 0 : _d.paginationLimit) !== null && _e !== void 0 ? _e : paginationLimit,
            },
        };
    }
    onPresenceUpdate(message) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.members.processPresenceMessage(message);
            yield this.locations.processPresenceMessage(message);
            yield this.locks.processPresenceMessage(message);
            this.emit('update', { members: yield this.members.getAll() });
        });
    }
    /**
     * <!-- BEGIN WEBSITE DOCUMENTATION (https://github.com/ably/docs/blob/cb5de6a6a40abdcb0d9d5af825928dd62dc1ca64/content/spaces/space.textile?plain=1#L43-L55) -->
     * Entering a space will register a client as a member and emit an {@link MembersEventMap.enter | `enter` } event to all subscribers. Use the `enter()` method to enter a space.
     *
     * Being entered into a space is required for members to:
     *
     * - { @link updateProfileData | Update their profile data. }
     * - { @link Locations.set | Set their location. }
     * - { @link Cursors.set | Set their cursor position. }
     *
     * The following is an example of entering a space:
     *
     * ```javascript
     * await space.enter();
     * ```
     * <!-- END WEBSITE DOCUMENTATION -->
     *
     * <!-- BEGIN WEBSITE DOCUMENTATION (https://github.com/ably/docs/blob/cb5de6a6a40abdcb0d9d5af825928dd62dc1ca64/content/spaces/space.textile?plain=1#L71-L82) -->
     * > **Moved documentation**
     * >
     * > This documentation has been moved to { @link ProfileData }.
     *
     * Profile data is returned in the payload of all space events.
     *
     * The following is an example of setting profile data when entering a space:
     *
     * ```javascript
     * await space.enter({
     *   username: 'Claire Oranges',
     *   avatar: 'https://slides-internal.com/users/coranges.png',
     * });
     * ```
     * <!-- END WEBSITE DOCUMENTATION -->
     *
     * <!-- BEGIN CLASS-DEFINITIONS DOCUMENTATION -->
     * Enter the space. Can optionally take `profileData`. This data can be an arbitrary JSON-serializable object which will be attached to the {@link SpaceMember | member object }. Returns all current space members.
     * <!-- END CLASS-DEFINITIONS DOCUMENTATION -->
     *
     * @param profileData Data to associate with the member who is entering the space.
     */
    enter(profileData = null) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => {
                const presence = this.channel.presence;
                const presenceListener = (presenceMessage) => __awaiter(this, void 0, void 0, function* () {
                    if (!(presenceMessage.clientId == this.client.auth.clientId &&
                        presenceMessage.connectionId == this.client.connection.id)) {
                        return;
                    }
                    presence.unsubscribe(presenceListener);
                    const presenceMessages = yield presence.get();
                    presenceMessages.forEach((msg) => this.locks.processPresenceMessage(msg));
                    const members = yield this.members.getAll();
                    resolve(members);
                });
                presence.subscribe(['enter', 'present'], presenceListener);
                const update = new SpaceUpdate_js_1.default({ self: null, extras: null });
                this.presenceEnter(update.updateProfileData(profileData));
            });
        });
    }
    updateProfileData(profileDataOrUpdateFn) {
        return __awaiter(this, void 0, void 0, function* () {
            const self = yield this.members.getSelf();
            if (!(0, is_js_1.isObject)(profileDataOrUpdateFn) && !(0, is_js_1.isFunction)(profileDataOrUpdateFn)) {
                throw new EventEmitter_js_1.InvalidArgumentError('Space.updateProfileData(): Invalid arguments: ' + (0, EventEmitter_js_1.inspect)([profileDataOrUpdateFn]));
            }
            let update = new SpaceUpdate_js_1.default({ self, extras: self ? this.locks.getLockExtras(self.connectionId) : null });
            if (!self) {
                const data = update.updateProfileData((0, is_js_1.isFunction)(profileDataOrUpdateFn) ? profileDataOrUpdateFn(null) : profileDataOrUpdateFn);
                yield this.presenceEnter(data);
                return;
            }
            else {
                const data = update.updateProfileData((0, is_js_1.isFunction)(profileDataOrUpdateFn) ? profileDataOrUpdateFn(self.profileData) : profileDataOrUpdateFn);
                return this.presenceUpdate(data);
            }
        });
    }
    /**
     * <!-- BEGIN WEBSITE DOCUMENTATION (https://github.com/ably/docs/blob/cb5de6a6a40abdcb0d9d5af825928dd62dc1ca64/content/spaces/space.textile?plain=1#L59-L67) -->
     * Leaving a space will emit a { @link MembersEventMap.leave | `leave` } event to all subscribers.
     *
     * The following is an example of explicitly leaving a space:
     *
     * ```javascript
     * await space.leave();
     * ```
     * Members will implicitly leave a space after 15 seconds if they abruptly disconnect. If experiencing network disruption, and they reconnect within 15 seconds, then they will remain part of the space and no `leave` event will be emitted.
     *
     * <!-- END WEBSITE DOCUMENTATION -->
     *
     * <!-- BEGIN CLASS-DEFINITIONS DOCUMENTATION -->
     * Leave the space. Can optionally take `profileData`. This triggers the `leave` event, but does not immediately remove the member from the space. See {@link SpaceOptions.offlineTimeout | offlineTimeout }.
     * <!-- END CLASS-DEFINITIONS DOCUMENTATION -->
     *
     * @param profileData If specified, this updated profile data will accompany the { @link MembersEventMap.leave | `leave` } event.
     */
    leave(profileData = null) {
        return __awaiter(this, arguments, void 0, function* () {
            const self = yield this.members.getSelf();
            if (!self) {
                throw (0, Errors_js_1.ERR_NOT_ENTERED_SPACE)();
            }
            const update = new SpaceUpdate_js_1.default({ self, extras: this.locks.getLockExtras(self.connectionId) });
            let data;
            // Use arguments so it's possible to deliberately nullify profileData on leave
            if (arguments.length > 0) {
                data = update.updateProfileData(profileData);
            }
            else {
                data = update.noop();
            }
            yield this.presenceLeave(data);
        });
    }
    /**
     * <!-- BEGIN WEBSITE DOCUMENTATION (https://github.com/ably/docs/blob/cb5de6a6a40abdcb0d9d5af825928dd62dc1ca64/content/spaces/space.textile?plain=1#L191-L197) -->
     * The current state of the space can be retrieved in a one-off call. This will return an array of all `member` objects currently in the space. This is a local call and retrieves the membership of the space retained in memory by the SDK.
     *
     * The following is an example of retrieving the current space state. Ths includes members that have recently left the space, but have not yet been removed:
     *
     * ```javascript
     * const spaceState = await space.getState();
     * ```
     * <!-- END WEBSITE DOCUMENTATION -->
     */
    getState() {
        return __awaiter(this, void 0, void 0, function* () {
            const members = yield this.members.getAll();
            return { members };
        });
    }
    subscribe(listenerOrEvents, listener) {
        try {
            super.on(listenerOrEvents, listener);
        }
        catch (e) {
            if (e instanceof EventEmitter_js_1.InvalidArgumentError) {
                throw new EventEmitter_js_1.InvalidArgumentError('Space.subscribe(): Invalid arguments: ' + (0, EventEmitter_js_1.inspect)([listenerOrEvents, listener]));
            }
            else {
                throw e;
            }
        }
    }
    unsubscribe(listenerOrEvents, listener) {
        try {
            super.off(listenerOrEvents, listener);
        }
        catch (e) {
            if (e instanceof EventEmitter_js_1.InvalidArgumentError) {
                throw new EventEmitter_js_1.InvalidArgumentError('Space.unsubscribe(): Invalid arguments: ' + (0, EventEmitter_js_1.inspect)([listenerOrEvents, listener]));
            }
            else {
                throw e;
            }
        }
    }
}
exports.default = Space;
//# sourceMappingURL=Space.js.map