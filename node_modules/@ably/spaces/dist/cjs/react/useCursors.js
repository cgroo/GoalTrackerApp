"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useCursors = void 0;
const react_1 = require("react");
const SpaceContext_js_1 = require("./contexts/SpaceContext.js");
const useMembers_js_1 = require("./useMembers.js");
const useChannelState_js_1 = require("./useChannelState.js");
const useConnectionState_js_1 = require("./useConnectionState.js");
const is_js_1 = require("../utilities/is.js");
function useCursors(callbackOrOptions, optionsOrNothing) {
    const space = (0, react_1.useContext)(SpaceContext_js_1.SpaceContext);
    const [cursors, setCursors] = (0, react_1.useState)({});
    const { members } = (0, useMembers_js_1.useMembers)();
    const channelError = (0, useChannelState_js_1.useChannelState)(space === null || space === void 0 ? void 0 : space.cursors.channel);
    const connectionError = (0, useConnectionState_js_1.useConnectionState)();
    const connectionIdToMember = (0, react_1.useMemo)(() => {
        return members.reduce((acc, member) => {
            acc[member.connectionId] = member;
            return acc;
        }, {});
    }, [members]);
    const callback = (0, is_js_1.isFunction)(callbackOrOptions) ? callbackOrOptions : undefined;
    const options = (0, is_js_1.isFunction)(callbackOrOptions) ? optionsOrNothing : callbackOrOptions;
    const callbackRef = (0, react_1.useRef)(callback);
    const optionsRef = (0, react_1.useRef)(options);
    (0, react_1.useEffect)(() => {
        callbackRef.current = callback;
        optionsRef.current = options;
    }, [callback, options]);
    (0, react_1.useEffect)(() => {
        if (!space || !connectionIdToMember)
            return;
        const listener = (cursorUpdate) => {
            var _a, _b, _c;
            if (!((_a = optionsRef.current) === null || _a === void 0 ? void 0 : _a.skip))
                (_b = callbackRef.current) === null || _b === void 0 ? void 0 : _b.call(callbackRef, cursorUpdate);
            const { connectionId } = cursorUpdate;
            if (connectionId === (space === null || space === void 0 ? void 0 : space.connectionId) || !((_c = optionsRef.current) === null || _c === void 0 ? void 0 : _c.returnCursors))
                return;
            setCursors((currentCursors) => (Object.assign(Object.assign({}, currentCursors), { [connectionId]: { member: connectionIdToMember[connectionId], cursorUpdate } })));
        };
        space.cursors.subscribe('update', listener);
        return () => {
            space.cursors.unsubscribe('update', listener);
        };
    }, [space, connectionIdToMember]);
    return {
        space,
        connectionError,
        channelError,
        set: space === null || space === void 0 ? void 0 : space.cursors.set.bind(space === null || space === void 0 ? void 0 : space.cursors),
        cursors,
    };
}
exports.useCursors = useCursors;
//# sourceMappingURL=useCursors.js.map