var Spaces=function(e){"use strict";const t=()=>new e.ErrorInfo("must enter a space to perform this operation",101001,400);function s(e){return Object.prototype.toString.call(e).slice(8,-1)}function n(e){return"Object"===s(e)}function i(e){return["Function","AsyncFunction","GeneratorFunction","Proxy"].includes(s(e))}function o(e){return"String"===s(e)}function a(e){return Array.isArray(e)}function r(e,t,s){try{t.apply(e,[s])}catch(e){console.error("EventEmitter.emit()","Unexpected listener exception: "+e+"; stack = "+(e&&e.stack))}}function c(e,t,s){let i,r,h;for(let l=0;l<e.length;l++)if(i=e[l],o(s)&&n(i)&&(i=i[s]),a(i)){for(;-1!==(r=i.indexOf(t));)i.splice(r,1);const o=e[l];s&&0===i.length&&n(o)&&delete o[s]}else if(n(i))for(h in i)Object.prototype.hasOwnProperty.call(i,h)&&a(i[h])&&c([i],t,h)}function h(e){return JSON.stringify(e)}class l extends Error{constructor(...e){super(...e)}}class u{constructor(){this.any=[],this.events=Object.create(null),this.anyOnce=[],this.eventsOnce=Object.create(null)}on(e,t){if(i(e))this.any.push(e);else if(o(e)&&i(t)){(this.events[e]||(this.events[e]=[])).push(t)}else{if(!a(e)||!i(t))throw new l("EventEmitter.on(): Invalid arguments: "+h([e,t]));e.forEach((e=>{this.on(e,t)}))}}off(e,t){if(!e&&!t)return this.any=[],this.events=Object.create(null),this.anyOnce=[],void(this.eventsOnce=Object.create(null));if(i(e))c([this.any,this.events,this.anyOnce,this.eventsOnce],e);else if(o(e)&&i(t))c([this.events,this.eventsOnce],t,e);else{if(o(e))return delete this.events[e],void delete this.eventsOnce[e];if(a(e)&&i(t))e.forEach((e=>{this.off(e,t)}));else{if(!a(e))throw new l("EventEmitter.off(): invalid arguments:"+h([e,t]));e.forEach((e=>{this.off(e)}))}}}listeners(e){var t;if(e){const s=[...null!==(t=this.events[e])&&void 0!==t?t:[]];return a(this.eventsOnce[e])&&Array.prototype.push.apply(s,this.eventsOnce[e]),s.length?s:null}return this.any.length?this.any:null}emit(e,t){const s={event:e},n=[];this.anyOnce.length>0&&(Array.prototype.push.apply(n,this.anyOnce),this.anyOnce=[]),this.any.length>0&&Array.prototype.push.apply(n,this.any);const i=this.eventsOnce[e];i&&(Array.prototype.push.apply(n,i),delete this.eventsOnce[e]);const o=this.events[e];o&&Array.prototype.push.apply(n,o),n.forEach((function(e){r(s,e,t)}))}once(e,t){if(o(e)&&i(t)){(this.eventsOnce[e]||(this.eventsOnce[e]=[])).push(t)}else{if(!i(e))throw new l("EventEmitter.once(): invalid arguments:"+h([e,t]));this.anyOnce.push(e)}}whenState(e,t,s,n){const i={event:e};if("string"!=typeof e||"string"!=typeof t)throw new l("whenState requires a valid event String argument");if("function"!=typeof s&&Promise)return new Promise((s=>{u.prototype.whenState.apply(this,[e,t,s,n])}));e===t?r(i,s,n):this.once(e,s)}}let d=(e=21)=>crypto.getRandomValues(new Uint8Array(e)).reduce(((e,t)=>e+=(t&=63)<36?t.toString(36):t<62?(t-26).toString(36).toUpperCase():t>62?"-":"_"),"");class p{constructor({self:e,extras:t}){this.self=e,this.extras=t}profileUpdate(e,t){return{id:e,current:t}}profileNoChange(){return this.profileUpdate(null,this.self?this.self.profileData:null)}locationUpdate(e,t,s){return{id:e,current:t,previous:s}}locationNoChange(){const e=this.self?this.self.location:null;return this.locationUpdate(null,e,null)}updateProfileData(e){return{data:{profileUpdate:this.profileUpdate(d(),e),locationUpdate:this.locationNoChange()},extras:this.extras}}updateLocation(e,t){var s;return{data:{profileUpdate:this.profileNoChange(),locationUpdate:this.locationUpdate(d(),e,t||(null===(s=this.self)||void 0===s?void 0:s.location))},extras:this.extras}}noop(){return{data:{profileUpdate:this.profileNoChange(),locationUpdate:this.locationNoChange()},extras:this.extras}}}class f extends u{constructor(e,t){super(),this.space=e,this.presenceUpdate=t,this.lastLocationUpdate={}}async processPresenceMessage(e){if("update"!==e.action)return;if(!e.data.locationUpdate.id||this.lastLocationUpdate[e.connectionId]===e.data.locationUpdate.id)return;const t=e.data.locationUpdate,{previous:s}=t,n=await this.space.members.getByConnectionId(e.connectionId);n&&(this.emit("update",{member:n,currentLocation:n.location,previousLocation:s}),this.lastLocationUpdate[e.connectionId]=e.data.locationUpdate.id)}async set(e){const s=await this.space.members.getSelf();if(!s)throw t();const n=new p({self:s,extras:this.space.locks.getLockExtras(s.connectionId)});await this.presenceUpdate(n.updateLocation(e))}subscribe(e,t){try{super.on(e,t)}catch(s){throw s instanceof l?new l("Locations.subscribe(): Invalid arguments: "+h([e,t])):s}}unsubscribe(e,t){try{super.off(e,t)}catch(s){throw s instanceof l?new l("Locations.unsubscribe(): Invalid arguments: "+h([e,t])):s}}async getSelf(){const e=await this.space.members.getSelf();return e?e.location:null}async getOthers(){return(await this.space.members.getOthers()).reduce(((e,t)=>(e[t.connectionId]=t.location,e)),{})}async getAll(){return(await this.space.members.getAll()).reduce(((e,t)=>(e[t.connectionId]=t.location,e)),{})}}const m="cursorUpdate";class g{constructor(e){this.outboundBatchInterval=e,this.outgoingBuffer=[],this.hasMovement=!1,this.isRunning=!1,this.shouldSend=!1,this.bufferStartTimestamp=0,this.batchTime=e}pushCursorPosition(e,t){if(!this.shouldSend)return;const s=(new Date).getTime();let n;0===this.outgoingBuffer.length?(n=0,this.bufferStartTimestamp=s):n=s-this.bufferStartTimestamp,this.hasMovement=!0,this.pushToBuffer({cursor:t,offset:n}),this.publishFromBuffer(e,m)}setShouldSend(e){this.shouldSend=e}setBatchTime(e){this.batchTime=e}pushToBuffer(e){this.outgoingBuffer.push(e)}async publishFromBuffer(e,t){this.isRunning||(this.isRunning=!0,await this.batchToChannel(e,t))}async batchToChannel(e,t){if(!this.hasMovement)return void(this.isRunning=!1);const s=[...this.outgoingBuffer];e.publish(t,s),setTimeout((()=>this.batchToChannel(e,t)),this.batchTime),this.outgoingBuffer=[],this.hasMovement=!1,this.isRunning=!0}}class b{constructor(e){this.emitCursorUpdate=e,this.buffer={}}setEmitCursorUpdate(e){this.emitCursorUpdate(e)}emitFromBatch(){for(let e in this.buffer){const t=this.buffer[e].shift();t&&setTimeout((()=>this.setEmitCursorUpdate(t.cursor)),t.offset)}this.bufferHaveData()&&this.emitFromBatch()}bufferHaveData(){return Object.entries(this.buffer).map((([,e])=>e)).flat().length>0}processBatch(e){(e.data||[]).forEach((t=>{const s={cursor:{clientId:e.clientId,connectionId:e.connectionId,position:t.cursor.position,data:t.cursor.data},offset:t.offset};this.buffer[s.cursor.connectionId]?this.buffer[s.cursor.connectionId].push(s):this.buffer[s.cursor.connectionId]=[s]})),this.bufferHaveData()&&this.emitFromBatch()}}class v{constructor(){}positionsMissing(e){return Object.keys(e).some((t=>null===e[t]))}messageToUpdate(e,t,s){return{clientId:t,connectionId:e,position:s.position,data:s.data}}allCursorUpdates(e,t){return Object.fromEntries(Object.entries(e).map((([e,s])=>{var n;const i=t.items.find((t=>t.connectionId===e));if(!i)return[e,s];const{data:o=[],clientId:a}=i,r=null===(n=o[o.length-1])||void 0===n?void 0:n.cursor,c=r?{clientId:a,connectionId:e,position:r.position,data:r.data}:null;return[e,c]})))}async getLastCursorUpdate(e,t){const s=await e.presence.get();if(0===s.length)return{};let n=s.reduce(((e,t)=>({...e,[t.connectionId]:null})),{});const i=await e.history();let o=1,a=await i.current();for(n=this.allCursorUpdates(n,a),o++;o<=t&&this.positionsMissing(n)&&i.hasNext();)a=await i.next(),n=this.allCursorUpdates(n,a),o++;return n}}class w extends u{constructor(e){super(),this.space=e,this.emitterHasListeners=e=>{const t=e=>Object.entries(e).map(((e,t)=>t)).flat();return e.any.length>0||e.anyOnce.length>0||t(e.events).length>0||t(e.eventsOnce).length>0},this.options=this.space.options.cursors,this.channelName=`${this.space.name}::$cursors`,this.cursorHistory=new v,this.cursorBatching=new g(this.options.outboundBatchInterval);this.cursorDispensing=new b((e=>this.emit("update",e)))}async set(e){if(!await this.space.members.getSelf())throw t();const s=this.getChannel();this.cursorBatching.pushCursorPosition(s,e)}getChannel(){var e;return null!==(e=this.channel)&&void 0!==e?e:this.channel=this.initializeCursorsChannel()}initializeCursorsChannel(){const e=this.space.client.channels.get(this.channelName);return e.presence.subscribe(this.onPresenceUpdate.bind(this)),e.presence.enter(),e}async onPresenceUpdate(){const e=this.getChannel(),t=await e.presence.get();this.cursorBatching.setShouldSend(t.length>1),this.cursorBatching.setBatchTime(t.length*this.options.outboundBatchInterval)}isUnsubscribed(){const e=this.getChannel().subscriptions;return!this.emitterHasListeners(e)}subscribe(e,t){try{super.on(e,t)}catch(s){throw s instanceof l?new l("Cursors.subscribe(): Invalid arguments: "+h([e,t])):s}if(this.isUnsubscribed()){this.getChannel().subscribe(m,(e=>{this.cursorDispensing.processBatch(e)}))}}unsubscribe(e,t){try{super.off(e,t)}catch(s){throw s instanceof l?new l("Cursors.unsubscribe(): Invalid arguments: "+h([e,t])):s}if(!this.emitterHasListeners(this)){this.getChannel().unsubscribe()}}async getSelf(){const e=await this.space.members.getSelf();if(!e)return null;return(await this.getAll())[e.connectionId]}async getOthers(){const e=await this.space.members.getSelf();if(!e)return{};const t=await this.getAll();return delete t[e.connectionId],t}async getAll(){const e=this.getChannel();return await this.cursorHistory.getLastCursorUpdate(e,this.options.paginationLimit)}}class y{constructor(e){this.offlineTimeout=e,this.leavers=[]}getByConnectionId(e){return this.leavers.find((t=>t.member.connectionId===e))}getAll(){return this.leavers}addLeaver(e,t){this.removeLeaver(e.connectionId),this.leavers.push({member:e,timeoutId:setTimeout(t,this.offlineTimeout)})}removeLeaver(e){const t=this.leavers.findIndex((t=>t.member.connectionId===e));t>=0&&(clearTimeout(this.leavers[t].timeoutId),this.leavers.splice(t,1))}}class I extends u{constructor(e){super(),this.space=e,this.lastMemberUpdate={},this.leavers=new y(this.space.options.offlineTimeout)}async processPresenceMessage(e){const{action:t,connectionId:s}=e,n=!!this.leavers.getByConnectionId(s),i=this.createMember(e);"leave"===t?(this.leavers.addLeaver(i,(()=>this.onMemberOffline(i))),this.emit("leave",i),this.emit("update",i)):n&&this.leavers.removeLeaver(s),"enter"===t&&(this.emit("enter",i),this.emit("update",i)),e.data.profileUpdate.id&&this.lastMemberUpdate[s]!==e.data.profileUpdate.id&&(this.lastMemberUpdate[e.connectionId]=e.data.profileUpdate.id,this.emit("updateProfile",i),this.emit("update",i))}async getSelf(){return this.space.connectionId?await this.getByConnectionId(this.space.connectionId):null}async getAll(){return(await this.space.channel.presence.get()).map((e=>this.createMember(e))).concat(this.leavers.getAll().map((e=>e.member)))}async getOthers(){return(await this.getAll()).filter((e=>e.connectionId!==this.space.connectionId))}subscribe(e,t){try{super.on(e,t)}catch(s){throw s instanceof l?new l("Members.subscribe(): Invalid arguments: "+h([e,t])):s}}unsubscribe(e,t){try{super.off(e,t)}catch(s){throw s instanceof l?new l("Members.unsubscribe(): Invalid arguments: "+h([e,t])):s}}async getByConnectionId(e){var t;return null!==(t=(await this.getAll()).find((t=>t.connectionId===e)))&&void 0!==t?t:null}createMember(e){return{clientId:e.clientId,connectionId:e.connectionId,isConnected:"leave"!==e.action,profileData:e.data.profileUpdate.current,location:e.data.locationUpdate.current,lastEvent:{name:e.action,timestamp:e.timestamp}}}async onMemberOffline(e){this.leavers.removeLeaver(e.connectionId),this.emit("remove",e),this.emit("update",e),e.location&&this.space.locations.emit("update",{previousLocation:e.location,currentLocation:null,member:{...e,location:null}}),this.space.emit("update",{members:await this.getAll()})}}class k extends u{constructor(e,t){super(),this.space=e,this.presenceUpdate=t,this.locks=new Map}get(e){const t=this.locks.get(e);if(t)for(const e of t.values())if("locked"===e.status)return{...e}}async getAll(){const e=[];for(const t of this.locks.values())for(const s of t.values())"locked"===s.status&&e.push({...s});return e}async getSelf(){const e=await this.space.members.getSelf();return e?this.getLocksForConnectionId(e.connectionId).filter((e=>"locked"===e.status)):[]}async getOthers(){const e=await this.space.members.getSelf(),t=await this.getAll();return e?t.filter((t=>t.member.connectionId!==e.connectionId)):t}async acquire(s,n){const i=await this.space.members.getSelf();if(!i)throw t();let o=this.getLock(s,i.connectionId);if(o&&"unlocked"!==o.status)throw new e.ErrorInfo("lock request already exists",101002,400);return o={id:s,status:"pending",timestamp:Date.now(),member:i},n&&(o.attributes=n.attributes),this.setLock(o),await this.updatePresence(i),o}async release(e){const s=await this.space.members.getSelf();if(!s)throw t();const n=this.getLock(e,s.connectionId);n&&(this.setLock({...n,status:"unlocked",reason:void 0}),this.updatePresence(s),this.deleteLock(e,s.connectionId))}subscribe(e,t){try{super.on(e,t)}catch(s){throw s instanceof l?new l("Locks.subscribe(): Invalid arguments: "+h([e,t])):s}}unsubscribe(e,t){try{super.off(e,t)}catch(s){throw s instanceof l?new l("Locks.unsubscribe(): Invalid arguments: "+h([e,t])):s}}async processPresenceMessage(e){var t;const s=await this.space.members.getByConnectionId(e.connectionId);if(s)if("leave"!==e.action&&Array.isArray(null===(t=null==e?void 0:e.extras)||void 0===t?void 0:t.locks)){e.extras.locks.forEach((e=>{const t=this.getLock(e.id,s.connectionId);"pending"!==e.status||t&&"pending"!==t.status||this.processPending(s,e),t&&t.status===e.status||this.emit("update",{...e,member:s}),this.setLock({...e,member:s})}));for(const e of this.locks.values())for(const t of e.values())"unlocked"===t.status&&this.deleteLock(t.id,t.member.connectionId)}else for(const e of this.locks.values()){const t=e.get(s.connectionId);if(t){const n={...t,status:"unlocked",reason:void 0};this.setLock(n),this.emit("update",n),e.delete(s.connectionId)}}}processPending(t,s){const n=this.get(s.id);if(n){if(s.timestamp<n.timestamp||s.timestamp==n.timestamp&&t.connectionId<n.member.connectionId){s.status="locked";const t={...n,status:"unlocked",reason:new e.ErrorInfo("lock was invalidated by a concurrent lock request which now holds the lock",101004,400)};return this.setLock(t),void this.emit("update",t)}s.status="unlocked",s.reason=new e.ErrorInfo("lock is currently locked",101003,400)}else s.status="locked"}updatePresence(e){const t=new p({self:e,extras:this.getLockExtras(e.connectionId)});return this.presenceUpdate(t.noop())}getLock(e,t){const s=this.locks.get(e);if(s)return s.get(t)}setLock(e){let t=this.locks.get(e.id);t||(t=new Map,this.locks.set(e.id,t)),t.set(e.member.connectionId,e)}deleteLock(e,t){const s=this.locks.get(e);if(s)return s.delete(t)}getLocksForConnectionId(e){const t=[];for(const s of this.locks.values()){const n=s.get(e);n&&t.push({...n})}return t}getLockExtras(e){const t=this.getLocksForConnectionId(e);if(0!==t.length)return{locks:t}}}const U="0.3.0",L={offlineTimeout:12e4,cursors:{outboundBatchInterval:25,paginationLimit:5}};class C extends u{constructor(t,s,n){super(),this.presenceUpdate=({data:t,extras:s})=>s?this.channel.presence.update(e.Realtime.PresenceMessage.fromValues({data:t,extras:s})):this.channel.presence.update(t),this.presenceEnter=({data:t,extras:s})=>s?this.channel.presence.enter(e.Realtime.PresenceMessage.fromValues({data:t,extras:s})):this.channel.presence.enter(t),this.presenceLeave=({data:t,extras:s})=>s?this.channel.presence.leave(e.Realtime.PresenceMessage.fromValues({data:t,extras:s})):this.channel.presence.leave(t),this.client=s,this.options=this.setOptions(n),this.connectionId=this.client.connection.id,this.name=t,this.channelName=`${t}::$space`,this.channel=this.client.channels.get(this.channelName,{params:{agent:`spaces/${U}`}}),this.onPresenceUpdate=this.onPresenceUpdate.bind(this),this.channel.presence.subscribe(this.onPresenceUpdate),this.locations=new f(this,this.presenceUpdate),this.cursors=new w(this),this.members=new I(this),this.locks=new k(this,this.presenceUpdate)}setOptions(e){var t,s,n,i,o;const{offlineTimeout:a,cursors:{outboundBatchInterval:r,paginationLimit:c}}=L;return{offlineTimeout:null!==(t=null==e?void 0:e.offlineTimeout)&&void 0!==t?t:a,cursors:{outboundBatchInterval:null!==(n=null===(s=null==e?void 0:e.cursors)||void 0===s?void 0:s.outboundBatchInterval)&&void 0!==n?n:r,paginationLimit:null!==(o=null===(i=null==e?void 0:e.cursors)||void 0===i?void 0:i.paginationLimit)&&void 0!==o?o:c}}}async onPresenceUpdate(e){await this.members.processPresenceMessage(e),await this.locations.processPresenceMessage(e),await this.locks.processPresenceMessage(e),this.emit("update",{members:await this.members.getAll()})}async enter(e=null){return new Promise((t=>{const s=this.channel.presence,n=async e=>{if(e.clientId!=this.client.auth.clientId||e.connectionId!=this.client.connection.id)return;s.unsubscribe(n);(await s.get()).forEach((e=>this.locks.processPresenceMessage(e)));const i=await this.members.getAll();t(i)};s.subscribe(["enter","present"],n);const i=new p({self:null,extras:null});this.presenceEnter(i.updateProfileData(e))}))}async updateProfileData(e){const t=await this.members.getSelf();if(!n(e)&&!i(e))throw new l("Space.updateProfileData(): Invalid arguments: "+h([e]));let s=new p({self:t,extras:t?this.locks.getLockExtras(t.connectionId):null});if(t){const n=s.updateProfileData(i(e)?e(t.profileData):e);return this.presenceUpdate(n)}{const t=s.updateProfileData(i(e)?e(null):e);return void await this.presenceEnter(t)}}async leave(e=null){const s=await this.members.getSelf();if(!s)throw t();const n=new p({self:s,extras:this.locks.getLockExtras(s.connectionId)});let i;i=arguments.length>0?n.updateProfileData(e):n.noop(),await this.presenceLeave(i)}async getState(){return{members:await this.members.getAll()}}subscribe(e,t){try{super.on(e,t)}catch(s){throw s instanceof l?new l("Space.subscribe(): Invalid arguments: "+h([e,t])):s}}unsubscribe(e,t){try{super.off(e,t)}catch(s){throw s instanceof l?new l("Space.unsubscribe(): Invalid arguments: "+h([e,t])):s}}}return class{constructor(e){this.spaces={},this.version=U,this.client=e,this.connection=e.connection,this.addAgent(this.client.options),this.client.time()}addAgent(e){var t;const s={"ably-spaces":this.version,"space-custom-client":!0};e.agents={...null!==(t=e.agents)&&void 0!==t?t:e.agents,...s}}async get(t,s){if("string"!=typeof t||0===t.length)throw new e.ErrorInfo("must have a non-empty name for the space",101e3,400);if("connected"!==this.connection.state&&await this.connection.once("connected"),this.spaces[t])return this.spaces[t];const n=new C(t,this.client,s);return this.spaces[t]=n,n}}}(Ably);