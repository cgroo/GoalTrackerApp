import { isArray, isFunction, isObject, isString } from './is.js';
function callListener(eventThis, listener, arg) {
    try {
        listener.apply(eventThis, [arg]);
    }
    catch (e) {
        console.error('EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
    }
}
/**
 * Remove listeners that match listener
 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
 * @param listener the listener callback to remove
 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
 */
export function removeListener(targetListeners, listener, eventFilter) {
    let listeners;
    let index;
    let eventName;
    for (let targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
        listeners = targetListeners[targetListenersIndex];
        if (isString(eventFilter) && isObject(listeners)) {
            listeners = listeners[eventFilter];
        }
        if (isArray(listeners)) {
            while ((index = listeners.indexOf(listener)) !== -1) {
                listeners.splice(index, 1);
            }
            /* If events object has an event name key with no listeners then
                       remove the key to stop the list growing indefinitely */
            const parentCollection = targetListeners[targetListenersIndex];
            if (eventFilter && listeners.length === 0 && isObject(parentCollection)) {
                delete parentCollection[eventFilter];
            }
        }
        else if (isObject(listeners)) {
            for (eventName in listeners) {
                if (Object.prototype.hasOwnProperty.call(listeners, eventName) && isArray(listeners[eventName])) {
                    removeListener([listeners], listener, eventName);
                }
            }
        }
    }
}
// Equivalent of Platform.config.inspect from ably-js for browser/RN
export function inspect(args) {
    return JSON.stringify(args);
}
export class InvalidArgumentError extends Error {
    constructor(...args) {
        super(...args);
    }
}
/**
 * `EventEmitter` represents an object which is capable of emitting one or more events, which are identified by their name. It provides methods which allow you to listen for these events. It serves as the base class for all of the event-emitting classes in the Spaces SDK.
 *
 * @typeParam T An object type, the names of whose properties are the names of the events that an instance of this class can emit.
 */
export default class EventEmitter {
    /**
     * @internal
     * @typeParam T An object type, the names of whose properties are the names of the events that the constructed object can emit.
     */
    constructor() {
        this.any = [];
        this.events = Object.create(null);
        this.anyOnce = [];
        this.eventsOnce = Object.create(null);
    }
    on(listenerOrEvents, listener) {
        // .on(() => {})
        if (isFunction(listenerOrEvents)) {
            this.any.push(listenerOrEvents);
            return;
        }
        // .on("eventName", () => {})
        if (isString(listenerOrEvents) && isFunction(listener)) {
            const listeners = this.events[listenerOrEvents] || (this.events[listenerOrEvents] = []);
            listeners.push(listener);
            return;
        }
        // .on(["eventName"], () => {})
        if (isArray(listenerOrEvents) && isFunction(listener)) {
            listenerOrEvents.forEach((eventName) => {
                this.on(eventName, listener);
            });
            return;
        }
        throw new InvalidArgumentError('EventEmitter.on(): Invalid arguments: ' + inspect([listenerOrEvents, listener]));
    }
    off(listenerOrEvents, listener) {
        // .off()
        // don't use arguments.length === 0 here as don't won't handle
        // cases like .off(undefined) which is a valid call
        if (!listenerOrEvents && !listener) {
            this.any = [];
            this.events = Object.create(null);
            this.anyOnce = [];
            this.eventsOnce = Object.create(null);
            return;
        }
        // .off(() => {})
        if (isFunction(listenerOrEvents)) {
            removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listenerOrEvents);
            return;
        }
        // .off("eventName", () => {})
        if (isString(listenerOrEvents) && isFunction(listener)) {
            removeListener([this.events, this.eventsOnce], listener, listenerOrEvents);
            return;
        }
        // .off("eventName")
        if (isString(listenerOrEvents)) {
            delete this.events[listenerOrEvents];
            delete this.eventsOnce[listenerOrEvents];
            return;
        }
        // .off(["eventName"], () => {})
        if (isArray(listenerOrEvents) && isFunction(listener)) {
            listenerOrEvents.forEach((eventName) => {
                this.off(eventName, listener);
            });
            return;
        }
        // .off(["eventName"])
        if (isArray(listenerOrEvents)) {
            listenerOrEvents.forEach((eventName) => {
                this.off(eventName);
            });
            return;
        }
        throw new InvalidArgumentError('EventEmitter.off(): invalid arguments:' + inspect([listenerOrEvents, listener]));
    }
    /**
     * Get the array of listeners for a given event; excludes once events
     * @param event (optional) the name of the event, or none for 'any'
     * @return array of events, or null if none
     *
     * @typeParam K A type which allows a name of the properties of {@link T}. TypeScript will infer this type based on the {@link event} argument.
     */
    listeners(event) {
        var _a;
        if (event) {
            const listeners = [...((_a = this.events[event]) !== null && _a !== void 0 ? _a : [])];
            if (isArray(this.eventsOnce[event])) {
                Array.prototype.push.apply(listeners, this.eventsOnce[event]);
            }
            return listeners.length ? listeners : null;
        }
        return this.any.length ? this.any : null;
    }
    /**
     * @internal
     *
     * Emit an event
     * @param event the event name
     * @param arg the arguments to pass to the listener
     */
    emit(event, arg) {
        const eventThis = { event };
        const listeners = [];
        if (this.anyOnce.length > 0) {
            Array.prototype.push.apply(listeners, this.anyOnce);
            this.anyOnce = [];
        }
        if (this.any.length > 0) {
            Array.prototype.push.apply(listeners, this.any);
        }
        const eventsOnceListeners = this.eventsOnce[event];
        if (eventsOnceListeners) {
            Array.prototype.push.apply(listeners, eventsOnceListeners);
            delete this.eventsOnce[event];
        }
        const eventsListeners = this.events[event];
        if (eventsListeners) {
            Array.prototype.push.apply(listeners, eventsListeners);
        }
        listeners.forEach(function (listener) {
            callListener(eventThis, listener, arg);
        });
    }
    once(listenerOrEvent, listener) {
        // .once("eventName", () => {})
        if (isString(listenerOrEvent) && isFunction(listener)) {
            const listeners = this.eventsOnce[listenerOrEvent] || (this.eventsOnce[listenerOrEvent] = []);
            listeners.push(listener);
            return;
        }
        // .once(() => {})
        if (isFunction(listenerOrEvent)) {
            this.anyOnce.push(listenerOrEvent);
            return;
        }
        throw new InvalidArgumentError('EventEmitter.once(): invalid arguments:' + inspect([listenerOrEvent, listener]));
    }
    /**
     * @internal
     *
     * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
     * @param targetState the name of the state event to listen to
     * @param currentState the name of the current state of this object
     * @param listener the listener to be called
     * @param listenerArg the argument to pass to the listener
     */
    whenState(targetState, currentState, listener, listenerArg) {
        const eventThis = { event: targetState };
        if (typeof targetState !== 'string' || typeof currentState !== 'string') {
            throw new InvalidArgumentError('whenState requires a valid event String argument');
        }
        if (typeof listener !== 'function' && Promise) {
            return new Promise((resolve) => {
                EventEmitter.prototype.whenState.apply(this, [targetState, currentState, resolve, listenerArg]);
            });
        }
        if (targetState === currentState) {
            callListener(eventThis, listener, listenerArg);
        }
        else {
            this.once(targetState, listener);
        }
    }
}
