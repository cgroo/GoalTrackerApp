var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CURSOR_UPDATE } from './CursorConstants.js';
export default class CursorBatching {
    constructor(outboundBatchInterval) {
        this.outboundBatchInterval = outboundBatchInterval;
        this.outgoingBuffer = [];
        // Set to `true` when a cursor position is in the buffer
        this.hasMovement = false;
        // Set to `true` when the buffer is actively being emptied
        this.isRunning = false;
        // Set to `true` if there is more than one user listening to cursors
        this.shouldSend = false;
        // Used for tracking offsets in the buffer
        this.bufferStartTimestamp = 0;
        this.batchTime = outboundBatchInterval;
    }
    pushCursorPosition(channel, cursor) {
        // Ignore the cursor update if there is no one listening
        if (!this.shouldSend)
            return;
        const timestamp = new Date().getTime();
        let offset;
        // First update in the buffer is always 0
        if (this.outgoingBuffer.length === 0) {
            offset = 0;
            this.bufferStartTimestamp = timestamp;
        }
        else {
            // Add the offset compared to the first update in the buffer
            offset = timestamp - this.bufferStartTimestamp;
        }
        this.hasMovement = true;
        this.pushToBuffer({ cursor, offset });
        this.publishFromBuffer(channel, CURSOR_UPDATE);
    }
    setShouldSend(shouldSend) {
        this.shouldSend = shouldSend;
    }
    setBatchTime(batchTime) {
        this.batchTime = batchTime;
    }
    pushToBuffer(value) {
        this.outgoingBuffer.push(value);
    }
    publishFromBuffer(channel, eventName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isRunning) {
                this.isRunning = true;
                yield this.batchToChannel(channel, eventName);
            }
        });
    }
    batchToChannel(channel, eventName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasMovement) {
                this.isRunning = false;
                return;
            }
            // Must be copied here to avoid a race condition where the buffer is cleared before the publish happens
            const bufferCopy = [...this.outgoingBuffer];
            channel.publish(eventName, bufferCopy);
            setTimeout(() => this.batchToChannel(channel, eventName), this.batchTime);
            this.outgoingBuffer = [];
            this.hasMovement = false;
            this.isRunning = true;
        });
    }
}
//# sourceMappingURL=CursorBatching.js.map