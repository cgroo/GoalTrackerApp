import { useContext, useEffect, useMemo, useRef, useState } from 'react';
import { SpaceContext } from './contexts/SpaceContext.js';
import { useMembers } from './useMembers.js';
import { useChannelState } from './useChannelState.js';
import { useConnectionState } from './useConnectionState.js';
import { isFunction } from '../utilities/is.js';
function useCursors(callbackOrOptions, optionsOrNothing) {
    const space = useContext(SpaceContext);
    const [cursors, setCursors] = useState({});
    const { members } = useMembers();
    const channelError = useChannelState(space === null || space === void 0 ? void 0 : space.cursors.channel);
    const connectionError = useConnectionState();
    const connectionIdToMember = useMemo(() => {
        return members.reduce((acc, member) => {
            acc[member.connectionId] = member;
            return acc;
        }, {});
    }, [members]);
    const callback = isFunction(callbackOrOptions) ? callbackOrOptions : undefined;
    const options = isFunction(callbackOrOptions) ? optionsOrNothing : callbackOrOptions;
    const callbackRef = useRef(callback);
    const optionsRef = useRef(options);
    useEffect(() => {
        callbackRef.current = callback;
        optionsRef.current = options;
    }, [callback, options]);
    useEffect(() => {
        if (!space || !connectionIdToMember)
            return;
        const listener = (cursorUpdate) => {
            var _a, _b, _c;
            if (!((_a = optionsRef.current) === null || _a === void 0 ? void 0 : _a.skip))
                (_b = callbackRef.current) === null || _b === void 0 ? void 0 : _b.call(callbackRef, cursorUpdate);
            const { connectionId } = cursorUpdate;
            if (connectionId === (space === null || space === void 0 ? void 0 : space.connectionId) || !((_c = optionsRef.current) === null || _c === void 0 ? void 0 : _c.returnCursors))
                return;
            setCursors((currentCursors) => (Object.assign(Object.assign({}, currentCursors), { [connectionId]: { member: connectionIdToMember[connectionId], cursorUpdate } })));
        };
        space.cursors.subscribe('update', listener);
        return () => {
            space.cursors.unsubscribe('update', listener);
        };
    }, [space, connectionIdToMember]);
    return {
        space,
        connectionError,
        channelError,
        set: space === null || space === void 0 ? void 0 : space.cursors.set.bind(space === null || space === void 0 ? void 0 : space.cursors),
        cursors,
    };
}
export { useCursors };
//# sourceMappingURL=useCursors.js.map